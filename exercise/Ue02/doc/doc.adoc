= Ãœbung 2
:author: Andreas Wenzelhuemer
:email: <S1910307106@fhooe.at>
:reproducible:
:experimental:
:listing-caption: Listing
:source-highlighter: rouge
:src: ../src
:img: ./img
:toc:
:numbered:
:toclevels: 5
:rouge-style: github

<<<

== Race conditions

=== Create an simple race condition

Simple race condition where x gets incremented.
Because twice threads increment x at the same time, a race condition occurs and x is 1 instead of two.
To prevent this a lock object gets created and the lock operation gets called each time x is incremented.

.Program with simple race condition
[source, csharp]
----
static readonly DateTime startTime = DateTime.Now.AddSeconds(1);

private static void RaceCondition()
{
    Console.WriteLine("With race condition");

    int x = 0;
    void incrementX()
    {
        while (DateTime.Now < startTime)
        {
            //do nothing
        }

        x++;
    }

    Thread worker1 = new(incrementX);
    Thread worker2 = new(incrementX);

    worker1.Start();
    worker2.Start();

    worker1.Join();
    worker2.Join();

    Console.WriteLine($"x => {x}");

}
----

.Fixed race condition with lock object
[source, csharp]
----
static readonly DateTime startTime = DateTime.Now.AddSeconds(1);
private static void FixedRaceCondition()
{
    Console.WriteLine("With fixed race condition");

    int x = 0;
    object locker = new();

    void incrementX()
    {
        while (DateTime.Now < startTime)
        {
            //do nothing
        }

        // Locking for x to prevent race condition
        lock (locker)
        {
            x++;
        }
    }

    Thread worker1 = new(incrementX);
    Thread worker2 = new(incrementX);

    worker1.Start();
    worker2.Start();

    worker1.Join();
    worker2.Join();

    Console.WriteLine($"x => {x}");
}
----


=== Find the race condition

The race condition occurs because the writer continuously adds new values to the buffer and old ones gets overwritten, because the writer doesn't wait for the reader.

One possible solution would be to use two events, one for the reader and one for the writer. Here both threads could be synchronized.
The buffer would be useless with this solution, thats why two semaphores were used instead.
One to signal the reader, that items are available to read and one to signal that an item was read successful and the writer can continue writing.
Both semaphores are initialized with a capacity of 10 to work correctly with the buffer.

.Semaphores
[source, csharp]
----
include::{src}/RaceConditions2/Program.cs[]
----

== Synchronisation primitives

The synchronisation is possible by using a thread pool where the size is set to 10.
All threads get added to the thread pool.

.Combine 10 downloads
[source, csharp]
----
include::{src}/SynchronizationPrimitives/Program.cs[lines=12..19]
----

This is possible by using Interlocked.Decrement where the count gets continually decreased. When the count is zero, an ManualResetEvent is used by calling Set(). Until set is called the method waits at the end with WaitOne().

.Combine all downloads
[source, csharp]
----
include::{src}/SynchronizationPrimitives/Program.cs[lines=21..35]
----