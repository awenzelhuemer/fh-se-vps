= Ãœbung 3
:author: Andreas Wenzelhuemer
:email: <S1910307106@fhooe.at>
:reproducible:
:experimental:
:listing-caption: Listing
:source-highlighter: rouge
:src: ../src
:img: ./img
:toc:
:numbered:
:toclevels: 5
:rouge-style: github

<<<
== Simple Mandelbrot generator

Mandelbrot generation was already finished in the lesson.
This is the code for the synchronous image generation.

.Image generation
[source, csharp]
----
include::{src}/MandelBrotGenerator/Generators/SyncImageGenerator.cs[]
----

<<<
== Worker thread

=== Solution with thread

One possible solution would be to create each time a new thread which starts the image execution. If the method is currently executing an image generation, the previous generation gets cancelled via `CancellationTokenSource`. Additionally if the image was generated successfully, an event gets fired where the new image, area and time gets passed with `EventArgs`.

.Image generator with thread
[source, csharp]
----
include::{src}/MandelBrotGenerator/Generators/AsyncThreadImageGenerator.cs[]
----

=== Solution with background worker

BackgroundWorker is used for image generation.
Previous worker gets cancelled if new worker gets created and started.
Two callback methods are used: `DoWork` and `RunWorkerCompleted`.
Additionally the flag `WorkerSupportsCancellation` has to be set.

.Image generator with background worker
[source, csharp]
----
include::{src}/MandelBrotGenerator/Generators/BackgroundWorkerImageGenerator.cs[]
----

<<<
== Parallelize work

The whole areal gets splitted into separate parts.
Each part gets calculated separately.
That means that for each each part an separate thread gets created.
The number of rows and columns can be configured over the setting for the worker count.
After the generation of each part they get merged into one bitmap.

.Image generator with parallel generator
[source, csharp]
----
include::{src}/MandelBrotGenerator/Generators/MultiAsyncThreadImageGenerator.cs[]
----

<<<
== Runtime measurement

The performance of the parallel generator is similar to the synchronized one.
That's because there is much overhead, for example the merging of the bitmap parts and the calculation for each part.
When the number of workers is changed to 8, the generation is twice as fast as the synchronized one.

image::{img}/Performance.jpg[]